/*	Script generated by SourcePawn IDE
 *
 *	Credits to Eric "ChickenLover" Johnson for the awesome bomb model!
 */

#pragma semicolon 1;
#include <steamtools>
#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <tf2_stocks>
//#include <tf2_hud>
#pragma newdecls required

#define BOMB1 "models/tnttimebomb/tnttimebomb.mdl"
#define BOMBMDL "models/tnttimebomb/tnttimebomb"
#define BOMBTEX "materials/tnttimebomb/tnttimebomb"
#define BOMB_SOUND "items/cart_explode.wav"
#define BOMB_TRIGGER "items/cart_explode_trigger.wav"
#define BOMB_BEEP "tools/ifm/beep.wav"
#define DEFUSE "items/cart_warning_single.mp3"
#define TWENTYSEC "vo/announcer_ends_20sec.mp3"
#define TENSEC "vo/announcer_ends_10sec.mp3"
#define FIVESEC "vo/announcer_ends_5sec.mp3"

#define WARNING "vo/mvm_bomb_alerts02.mp3"

#define PLUGIN_VERSION "0.6"


Handle BombRetrieveTime = INVALID_HANDLE;
Handle BombTime = INVALID_HANDLE;
Handle CenterExplosionDamage = INVALID_HANDLE;
Handle DefuseTime = INVALID_HANDLE;
Handle ExplosionRadius = INVALID_HANDLE;
Handle LookAngle = INVALID_HANDLE;
Handle PlantTime = INVALID_HANDLE;
Handle RedWinTime = INVALID_HANDLE;
Handle Pushscale = INVALID_HANDLE;
Handle g_Cvar_GameDescription = INVALID_HANDLE;

int bombTime;
float plantTime;
float defuseTime;
float lookAngle;

bool BombDropped = false;
bool InBombArea[MAXPLAYERS+1] = { false, ... };
bool NooneHaveBomb = false;
bool Planted = false;
bool Planting[MAXPLAYERS+1] = { false, ... };
bool ShowHelp[MAXPLAYERS+1] = { true, ... };

Handle BombTimer = INVALID_HANDLE;
Handle RedWin = INVALID_HANDLE;
Handle RestTimer = INVALID_HANDLE;
Handle plantdefuse[MAXPLAYERS+1];

float BombLoc[3];
float BombPlantTime;
float PlantTimeF;
float nextBeep;

int ClientWithBomb = -1;
int bomb = -1;
int BombDropper = -1;
int Case[MAXPLAYERS+1] = { 0, ... };
int droppedbomb = -1;
int PlantingClient = -1;
int round = 0;
int team_round_timer = -1;
int team_round_timer_blu = -1;
bool g_bSteamTools = false;


public Plugin myinfo = 
{
	name = "Bomb Fortress",
	author = "TonyBaretta",
	description = "A Team Fortress 2 bomb mod",
	version = PLUGIN_VERSION,
	url = ""
};
public void OnMapStart()
{
	char modelext[][] = {".dx80.vtx", ".dx90.vtx", ".mdl", ".sw.vtx", ".vvd"};
	for (int i = 0; i < 5; i++)
	{
		char file[PLATFORM_MAX_PATH];
		Format(file, sizeof(file), "%s%s", BOMBMDL, modelext[i]);
		AddFileToDownloadsTable(file);
	}
	char texext[][] = {".vmt", ".vtf", "_blu.vmt", "_blu.vtf", "_ntr.vmt", "_ntr.vtf", "_pickedup.vmt", "_pickedup_blu.vmt", "_pickedup_ntr.vmt"};
	for (int i = 0; i < 9; i++)
	{
		char file[PLATFORM_MAX_PATH];
		Format(file, sizeof(file), "%s%s", BOMBTEX, texext[i]);
		AddFileToDownloadsTable(file);
	}
	PrecacheModel(BOMB1, true);
	PrecacheSound("mvm/mvm_bomb_explode.wav", true);
	PrecacheSound("items/cart_explode_trigger.wav", true);
	PrecacheSound("tools/ifm/beep.wav", true);
	PrecacheSound("items/cart_warning_single.wav", true);
	PrecacheSound("vo/announcer_ends_20sec.mp3", true);
	PrecacheSound("vo/announcer_ends_10sec.mp3", true);
	PrecacheSound("vo/announcer_ends_5sec.mp3", true);
	PrecacheSound("vo/mvm_bomb_alerts02.mp3", true);
	char file[256];
	BuildPath(Path_SM, file, 255, "configs/bombfortress.ini");
	Handle fileh = OpenFile(file, "r");
	if (fileh != INVALID_HANDLE)
	{
		char buffer[256];
		char buffer_full[PLATFORM_MAX_PATH];

		while(ReadFileLine(fileh, buffer, sizeof(buffer)))
		{
			TrimString(buffer);
			if ( (StrContains(buffer, "//") == -1) && (!StrEqual(buffer, "")) )
			{
				PrintToServer("Reading overlay_downloads line :: %s", buffer);
				Format(buffer_full, sizeof(buffer_full), "%s", buffer);
				if (FileExists(buffer_full))
				{
					PrintToServer("Precaching %s", buffer);
					PrecacheSound(buffer, true);
					AddFileToDownloadsTable(buffer_full);
				}
			}
		}
	}	
}
public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	MarkNativeAsOptional("Steam_SetGameDescription");
	return APLRes_Success;
}
public void OnPluginStart()
{
	LoadTranslations("common.phrases");
	CreateConVar("bomb_version", PLUGIN_VERSION, "Current Bomb Fortress version", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
	PlantTime = CreateConVar("bomb_plant_time", "1.5", "The time it takes to plant the bomb", FCVAR_PLUGIN, true, 1.0, true, 30.0);
	DefuseTime = CreateConVar("bomb_defuse_time", "5.0", "The time it takes to defuse the bomb", FCVAR_PLUGIN, true, 1.0, true, 30.0);
	BombTime = CreateConVar("bomb_time", "60.0", "The time it takes for the bomb to explode", FCVAR_PLUGIN, true, 1.0, true, 300.0);
	ExplosionRadius = CreateConVar("bomb_explosion_radius", "1200", "The radius of the explosion", FCVAR_PLUGIN, true, 0.0);
	CenterExplosionDamage = CreateConVar("bomb_explosion_damage", "1200", "The damage the explosion makes at the center of the explosion", FCVAR_PLUGIN, true, 0.0);
	LookAngle = CreateConVar("bomb_look_angle", "45", "The Highest angle (up/down) to look for being able to plant/defuse the bomb, less is higher", FCVAR_PLUGIN, true, -89.0, true, 89.0);
	RedWinTime = CreateConVar("bomb_red_round_time", "360.0", "The time red have to defend the point", FCVAR_PLUGIN, true, 180.0, true, 900.0);
	BombRetrieveTime = CreateConVar("bomb_return_time", "15", "The time it takes for the bomb to automatically be retrieved", FCVAR_PLUGIN, true, 0.1, true, 240.0);
	Pushscale = CreateConVar("bomb_explosion_pushscale", "1000", "The force to be applied on an explosion", FCVAR_PLUGIN);
	g_Cvar_GameDescription = CreateConVar("bombfortress_gamedescription", "1.0", "If SteamTools is loaded, set the Game Description to BombFortress?", FCVAR_PLUGIN, true, 0.0, true, 1.0);
	AutoExecConfig(true, "bombfortress");
	AddCommandListener(cmd_drop, "dropitem");
	AddNormalSoundHook(SoundHook);
	RegConsoleCmd("sm_bombhelp", cmd_help);
	RegConsoleCmd("sm_drop", cmd_drop2);
	RegAdminCmd("sm_force_drop", cmd_forcedrop, ADMFLAG_KICK);
	HookConVarChange(g_Cvar_GameDescription, Cvar_GameDescription);

	HookEvent("controlpoint_starttouch", Event_CPStartTouch, EventHookMode_Post);
	HookEvent("controlpoint_endtouch", Event_CPEndTouch, EventHookMode_Post);
	HookEvent("teamplay_round_start", Event_Roundstart, EventHookMode_PostNoCopy);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode_Post);
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode_Post);
}
public void OnAllPluginsLoaded()
{
	g_bSteamTools = LibraryExists("SteamTools");
}

public void OnLibraryAdded(const char[] name)
{
	if (StrEqual(name, "SteamTools", false))
	{
		g_bSteamTools = true;
	}
}

public void OnLibraryRemoved(const char[] name)
{
	if (StrEqual(name, "SteamTools", false))
	{
		g_bSteamTools = false;
	}
}
public void OnConfigsExecuted()
{	
	UpdateGameDescription(true);
}
public Action cmd_drop2(int client, int args)
{
	if(IsValidClient(client) && ClientWithBomb == client){
		DropBomb(client, false);
	}
	return Plugin_Handled;
}
public Action cmd_help(int client, int args)
{
	if (client > 0)
	{
		DisplayHelp(client);
	}
	return Plugin_Handled;
}
public void Cvar_GameDescription(Handle convar, const char[] oldValue, const char[] newValue)
{
	UpdateGameDescription();
}

public Action cmd_forcedrop(int client, int args)
{
	if (ClientWithBomb != -1 && IsValidClient(ClientWithBomb))
	{
		DropBomb(ClientWithBomb, false, true);
	}
	return Plugin_Handled;
}

public Action cmd_drop(int client, const char[] command, int argc)
{
	if(IsValidClient(client) && ClientWithBomb == client){
		DropBomb(client, false);
	}
	return Plugin_Continue;
}

public void OnClientDisconnect(int client)
{
	if (ClientWithBomb == client)
	{
		DropBomb(client);
	}
	Case[client] = 0;
	ShowHelp[client] = true;
	InBombArea[client] = false;
	Planting[client] = false;
	if (plantdefuse[client] != INVALID_HANDLE)
	{
		KillTimer(plantdefuse[client]);
		plantdefuse[client] = INVALID_HANDLE;
	}
}
int PrepareEntities()
{	 
	int ent = -1;
	while ((ent = FindEntityByClassname(ent, "trigger_capture_area")) != -1)
	{
		SetVariantString("2 0");
		AcceptEntityInput(ent, "SetTeamCanCap");
		SetVariantString("3 0");
		AcceptEntityInput(ent, "SetTeamCanCap");
	}
	bool koth = false;
	ent = -1;
	while ((ent = FindEntityByClassname(ent, "tf_logic_koth")) != -1)
	{
		koth = true;
	}
	ent = -1;
	while ((ent = FindEntityByClassname(ent, "team_round_timer")) != -1)
	{
		if (koth)
		{
			char name[32];
			GetEntPropString(ent, Prop_Data, "m_iName", name, sizeof(name));
			if (!strcmp("zz_red_koth_timer", name))
			{
				SetVariantInt(GetConVarInt(RedWinTime));
				AcceptEntityInput(ent, "SetTime");
				AcceptEntityInput(ent, "Resume");
				team_round_timer = ent;
			}
			else if (!strcmp("zz_blue_koth_timer", name))
			{
				SetVariantInt(0);
				AcceptEntityInput(ent, "AutoCountdown");
				SetVariantInt(bombTime);
				AcceptEntityInput(ent, "SetTime");
				team_round_timer_blu = ent;
			}
			continue;
		}
		char output[128];
		Format(output, sizeof(output), "OnRoundStart !self:kill::0.0:1");
		SetVariantString(output);
		AcceptEntityInput(ent, "AddOutput");
		HookSingleEntityOutput(ent, "OnRoundStart", OnRoundStart, true);
	}
}
public Action Event_CPEndTouch(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetEventInt(event, "player");
	if(IsValidClient(client)){
		InBombArea[client] = false;
		SetClientOverlay(client, "");
	}
}

public Action Event_CPStartTouch(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetEventInt(event, "player");
	if(IsValidClient(client)){
		InBombArea[client] = true;
		if ((ClientWithBomb == client) && InBombArea[client])
		{
			SetClientOverlay(client, "bombfortress/plant_bomb_ov");
		}
		if (Planted && GetClientTeam(client) == 2)
		{
			SetClientOverlay(client, "bombfortress/defuse_bomb_ov");
		}
	}
}

public Action Event_PlayerDeath(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (plantdefuse[client] != INVALID_HANDLE)
	{
		KillTimer(plantdefuse[client]);
		plantdefuse[client] =  INVALID_HANDLE;
	}
	if(IsValidClient(client)){
		if (ClientWithBomb == client)
		{
			DropBomb(client);
		}
		SetClientOverlay(client, "");
	}
}

public Action Event_PlayerSpawn(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsValidClient(client)){
		SetClientOverlay(client, "");
		SetEntProp(client, Prop_Send, "m_bGlowEnabled", 0, 1);
		if (ShowHelp[client])
		{
			DisplayHelp(client);
			PrintToChat (client, "\x01输入 \x03 !bombhelp \x01 来读 \x03 炸弹模式规则(汉化byfafa_junhe)");
		}
		if(IsValidClient(client) && GetClientTeam(client) == 3){
			if (NooneHaveBomb && !IsFakeClient(client) && GetClientTeam(client) == 3)
			{		
				NooneHaveBomb = false;
				ClientWithBomb = client;
				SetEntProp(client, Prop_Send, "m_bGlowEnabled", 1, 1);
				//SetEntityRenderColor(client, 0, 0, 0);
				PrintToHud(client,"你得到炸弹了!,在控制点上蹲下看地下按住右键来放置炸弹!");
				PrintToHudAll("%N 捡起了炸弹!", client);
				
			}
			else if (ClientWithBomb == client)
			{
				SetEntProp(client, Prop_Send, "m_bGlowEnabled", 1, 1);
			}
		}
/* 		if(IsValidClient(client) && GetClientTeam(client) == 2){
			if (Status[client] == RobotStatus_Robot) 
			{
				SetVariantString("");
				AcceptEntityInput(client, "SetCustomModel");
				LastTransformTime[client] = GetTickedTime();
				Status[client] = RobotStatus_Human;
				//SetWearableAlpha(client, 255);
			}
		} */
	}
}

public Action Event_Roundstart(Event event, const char[] name, bool dontBroadcast)
{
	round++;
	bomb = -1;
	droppedbomb = -1;
	ClientWithBomb = -1;
	team_round_timer = -1;
	team_round_timer_blu = -1;
	Planted = false;
	PlantTimeF = 0.0;
	BombDropped = false;
	BombLoc = NULL_VECTOR;
	bombTime = GetConVarInt(BombTime);
	plantTime = GetConVarFloat(PlantTime);
	defuseTime = GetConVarFloat(DefuseTime);
	lookAngle = GetConVarFloat(LookAngle);
	for (int client = 1; client <= MaxClients; client++)
	{
		if (IsValidClient(client))
		{
			//SetEntityRenderColor(client);
			SetEntProp(client, Prop_Send, "m_bGlowEnabled", 0, 1);
		}
		if (plantdefuse[client] != INVALID_HANDLE)
		{
			KillTimer(plantdefuse[client]);
			plantdefuse[client] = INVALID_HANDLE;
			AcceptEntityInput(team_round_timer_blu, "Resume");
		}
	}
	if (BombTimer != INVALID_HANDLE)
	{
		KillTimer(BombTimer);
		BombTimer = INVALID_HANDLE;
	}
	if (RestTimer != INVALID_HANDLE)
	{
		KillTimer(RestTimer);
		RestTimer = INVALID_HANDLE;
	}
	if (RedWin != INVALID_HANDLE)
	{
		KillTimer(RedWin);
		RedWin = INVALID_HANDLE;
	}
	RedWin = CreateTimer(GetConVarFloat(RedWinTime), timer_RedWin);
	GiveBlueBomb();
	PrepareEntities();
}
public void OnRoundStart(const char[] output, int caller, int activator, float delay)
{
	team_round_timer = CreateEntityByName("team_round_timer");
	if (IsValidEdict(team_round_timer))
	{
		if (RedWin != INVALID_HANDLE)
		{
			KillTimer(RedWin);
			RedWin = INVALID_HANDLE;
		}
		char timer_length[64];
		IntToString(GetConVarInt(RedWinTime), timer_length, sizeof(timer_length));
		DispatchKeyValue(team_round_timer, "timer_length", timer_length);
		DispatchSpawn(team_round_timer);
		SetVariantInt(1);
		AcceptEntityInput(team_round_timer, "ShowInHUD");
		AcceptEntityInput(team_round_timer, "Resume");
		HookSingleEntityOutput(team_round_timer, "OnFinished", OnFinished, true);
	}
}

public void OnFinished(const char[] output, int caller, int activator, float delay)
{
	if (Planted)
	{
		ExplodeBomb();
		return;
	}
	SetWinningTeam(2);
}

public Action timer_RedWin(Handle timer)
{
	SetWinningTeam(2);
	KillTimer(RedWin);
	RedWin = INVALID_HANDLE;
}

public Action OnPlayerRunCmd(int client, int &buttons, int &impulse, float vel[3], float angles[3], int &weapon)
{
	int flags = GetEntityFlags(client);
	if (!BombDropped && (client == PlantingClient || PlantingClient == -1) && flags & FL_ONGROUND && buttons & IN_DUCK && buttons & IN_ATTACK2)
	{
		int team = GetClientTeam(client);
		if (Planted && team == 2)
		{
			float vec[3];
			GetClientAbsOrigin(client, vec);
			if (angles[0] >= lookAngle/*GetConVarFloat(LookAngle)*/ && GetVectorDistance(BombLoc, vec, true) <= 400.0)
			{
				buttons &=~ IN_ATTACK;
				buttons &=~ IN_ATTACK2;
				if (plantdefuse[client] == INVALID_HANDLE)
				{
					PlantingClient = client;
					PlantTimeF = GetEngineTime();
					SetEntityMoveType(client, MOVETYPE_NONE);
					plantdefuse[client] = CreateTimer(0.1, defuse, client, TIMER_REPEAT);						
					EmitSoundToAll(DEFUSE);						
					TF2_RemoveCondition(client, TFCond_Ubercharged);
					TF2_RemoveCondition(client, TFCond_Disguised);
					TF2_RemoveCondition(client, TFCond_Bonked);
					TF2_RemoveCondition(client, TFCond_Cloaked);					
				}
				return Plugin_Changed;					
			}									
		}
		else if (ClientWithBomb == client)
		{
			if (angles[0] >= lookAngle/*GetConVarFloat(LookAngle)*/ && InBombArea[client])
			{
				buttons &=~ IN_ATTACK;
				buttons &=~ IN_ATTACK2;
				if (plantdefuse[client] == INVALID_HANDLE)
				{
					PlantingClient = client;
					PlantTimeF = GetEngineTime();
					SetEntityMoveType(client, MOVETYPE_NONE);
					plantdefuse[client] = CreateTimer(0.1, plant, client, TIMER_REPEAT);
				}
				return Plugin_Changed;
			}
		}
			
	}
	if (client == PlantingClient)
	{
		if (plantdefuse[client] != INVALID_HANDLE)
		{
			PlantTimeF = 0.0;
			PlantingClient = -1;
			SetEntityMoveType(client, MOVETYPE_WALK);
			KillTimer(plantdefuse[client]);
			plantdefuse[client] = INVALID_HANDLE;
		}
	}
	return Plugin_Continue;
}

public Action plant(Handle timer, any client)
{
	if (IsPlayerAlive(client))
	{
		float time = GetEngineTime() - PlantTimeF;
		PrintCenterText(client, "放置炸弹中: %d%", RoundToFloor(time / plantTime * 100.0));
		if (time >= plantTime)
		{
			//SetEntityRenderColor(client);
			SetEntProp(client, Prop_Send, "m_bGlowEnabled", 0, 1);
			SetEntityMoveType(client, MOVETYPE_WALK);
			PlantTimeF = 0.0;
			PlantingClient = -1;
			ClientWithBomb = -1;
			KillTimer(plantdefuse[client]);
			plantdefuse[client] = INVALID_HANDLE;
			PlantBomb(client);
		}
		TF2_RemoveCondition(client, TFCond_Ubercharged);
		TF2_RemoveCondition(client, TFCond_Disguised);
		TF2_RemoveCondition(client, TFCond_Bonked);
		TF2_RemoveCondition(client, TFCond_Cloaked);
	}
}

int PlantBomb(int client)
{
	if (IsValidEdict(bomb) || BombTimer != INVALID_HANDLE)
	{
		return;
	}
		
	bomb = CreateEntityByName("item_teamflag");//CreateEntityByName("prop_dynamic");
	
	if (IsValidEdict(bomb))
	{
		float ang[3]; float pos[3];

		GetClientAbsAngles(client, ang);
		FixAngles(ang);
		GetClientAbsOrigin(client, pos);
		DropPosition(pos, BombLoc);
		BombLoc[2] += 5;
		
		TeleportEntity(bomb, BombLoc, ang, NULL_VECTOR);
		BombLoc[2] -= 5;

		DispatchKeyValue(bomb, "flag_model"/*"model"*/, BOMB1);
		DispatchKeyValue(bomb, "skin", "2");
		DispatchKeyValue(bomb, "targetname", "bomb");
		DispatchKeyValue(bomb, "trail_effect", "0");

		DispatchSpawn(bomb);
		
		SetEntProp(bomb, Prop_Send, "m_iTeamNum", 2);
		SDKHook(bomb, SDKHook_Touch, bombtouch);
		EmitSoundToAll("vo/mvm_bomb_alerts02.mp3");

		nextBeep = float(bombTime);
		BombPlantTime = GetEngineTime();
		if (IsValidEdict(team_round_timer_blu))
		{
			AcceptEntityInput(team_round_timer_blu, "Resume");
			AcceptEntityInput(team_round_timer, "Pause");
			HookSingleEntityOutput(team_round_timer_blu, "OnFinished", OnFinished, true);
			HookSingleEntityOutput(team_round_timer_blu, "On1SecRemain", On1SecRemain, true);
			BombTimer = CreateTimer(0.1, timer_beep, round, TIMER_REPEAT);
		}
		else if (IsValidEdict(team_round_timer))
		{
			SetVariantInt(bombTime);
			AcceptEntityInput(team_round_timer, "SetTime");
			SetVariantInt(0);
			AcceptEntityInput(team_round_timer, "AutoCountdown");
			HookSingleEntityOutput(team_round_timer, "On1SecRemain", On1SecRemain, true);
			BombTimer = CreateTimer(0.1, timer_beep, round, TIMER_REPEAT);
		}
		else
		{
			BombTimer = CreateTimer(0.1, timer_bomb, round, TIMER_REPEAT);
		}
		
		if (RedWin != INVALID_HANDLE)
		{
			KillTimer(RedWin);
			RedWin = INVALID_HANDLE;
		}
		Planted = true;
		PrintToHudAll("炸弹被放置了!");
	}
}

public void On1SecRemain(const char[] output, int caller, int activator, float delay)
{
	//PrefetchSound(BOMB_TRIGGER);
	EmitAmbientSound(BOMB_TRIGGER, BombLoc, _, SNDLEVEL_SCREAMING);
	KillTimer(BombTimer);
	BombTimer = INVALID_HANDLE;
}

public Action timer_beep(Handle timer, any round2)
{
	if (round2 == round)
	{
		float difference = GetEngineTime() - BombPlantTime;
		float time = bombTime - difference;
		if (time <= nextBeep)
		{
			//PrefetchSound(BOMB_BEEP);
			EmitAmbientSound(BOMB_BEEP, BombLoc, _, SNDLEVEL_MINIBIKE, SND_CHANGEPITCH, _, SNDPITCH_HIGH);
			if (time <= 5.0)
			{
				nextBeep = time - 0.5;
			}
			else if (time <= 10.0)
			{
				nextBeep = time - 1.0;
			}
			else if (time <= 20.0)
			{
				nextBeep = time - 2.0;
			}
			else if (time <= 40.0)
			{
				nextBeep = time - 4.0;
			}
			else
			{
				nextBeep = time - 5.0;
			}
		}
	}
	else
	{
		KillTimer(BombTimer);
		BombTimer = INVALID_HANDLE;
	}
}

public Action timer_bomb(Handle timer, any round2)
{
	if (round2 == round)
	{
		float difference = GetEngineTime() - BombPlantTime;
		float time = bombTime - difference;
		if (time <= nextBeep)
		{
			if (time <= 1.5)
			{
				//PrefetchSound(BOMB_TRIGGER);
				EmitAmbientSound(BOMB_TRIGGER, BombLoc, _, SNDLEVEL_SCREAMING);
				nextBeep = 0.0;
			}
			else
			{
				//PrefetchSound(BOMB_BEEP);
				EmitAmbientSound(BOMB_BEEP, BombLoc, _, SNDLEVEL_MINIBIKE, SND_CHANGEPITCH, _, SNDPITCH_HIGH);
				if (time <= 5.0)
				{
					nextBeep = time - 0.5;
				}
				else if (time <= 10.0)
				{
					nextBeep = time - 1.0;
				}
				else if (time <= 20.0)
				{
					nextBeep = time - 2.0;
				}
				else if (time <= 40.0)
				{
					nextBeep = time - 4.0;
				}
				else
				{
					nextBeep = time - 5.0;
				}
			}
		}
		if (time <= 0.0)
		{
			ExplodeBomb();
		}
		if (time > 0.0)
		{
			switch (time)
			{
				case 20:
				{
					PrintToHudAll("炸弹还有20秒爆炸");
					EmitSoundToAll("vo/announcer_ends_20sec.mp3");
				}
				case 10:
				{
					PrintToHudAll("炸弹还有10秒爆炸");
					EmitSoundToAll("vo/announcer_ends_10sec.mp3");
				}
				case 5:
				{
					PrintToHudAll("炸弹还有5秒爆炸");
					EmitSoundToAll("vo/announcer_ends_5sec.mp3");
				}
				case 4:
				{
					PrintToHudAll("炸弹还有4秒爆炸");
					EmitSoundToAll("vo/announcer_ends_4sec.mp3");
				}
				case 3:
				{
					PrintToHudAll("炸弹还有3秒爆炸");
					EmitSoundToAll("vo/announcer_ends_3sec.mp3");
				}
				case 2:
				{
					PrintToHudAll("炸弹还有2秒爆炸");
					EmitSoundToAll("vo/announcer_ends_2sec.mp3");
				}
				case 1:
				{
					PrintToHudAll("炸弹还有1秒爆炸");
					EmitSoundToAll("vo/announcer_ends_1sec.mp3");
				}
			}
		}				 
	}
	else
	{
		KillTimer(BombTimer);
		BombTimer = INVALID_HANDLE;
	}
}

int ExplodeBomb()
{
	int particle = CreateEntityByName("info_particle_system");
	if (IsValidEdict(particle))
	{
		TeleportEntity(particle, BombLoc, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", "cinefx_goldrush");
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.5, DeleteParticles, particle);
		//PrefetchSound(BOMB_SOUND);
		EmitAmbientSound("items/cart_explode.wav", BombLoc, bomb, SNDLEVEL_SCREAMING);
		Damage();
		RemoveBomb(3);
		PrintToHudAll("目标被摧毁,蓝队获胜!");
	}
}

public Action DeleteParticles(Handle timer, any particle)
{
	if (IsValidEdict(particle))
	{
		char classname[64];
		GetEdictClassname(particle, classname, sizeof(classname));
		if (StrEqual(classname, "info_particle_system", false))
		{
			AcceptEntityInput(particle, "Kill");
		}
	}
}

int Damage()
{
	float radius; float dmg;
	
	radius = GetConVarFloat(ExplosionRadius);
	dmg = GetConVarFloat(CenterExplosionDamage);
	
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i) && IsPlayerAlive(i))
		{
			float pos[3]; float altpos[3]; float bl[3];
			bool useAltDmg; float dist; float altdist;
			
			bl = BombLoc;
			bl[2] += 32;
			
			GetClientAbsOrigin(i, pos);
			dist = GetVectorDistance(pos, bl);
			
			if (dist <= radius)
			{
				Handle Tracing = TR_TraceRayFilterEx(bl, pos, MASK_SOLID, RayType_EndPoint, AllowPlayers);
				int index;
				index = TR_GetEntityIndex(Tracing);
				CloseHandle(Tracing);
				if (index == -1 || index == i)
				{
					float damage;
					damage = dmg * (radius - dist) / radius;
					bl[2] -= 64;
					PushDamagePlayer(i, damage, bl, pos, dist, radius);
					continue;
				}
				else
				{
					altpos = pos;
					altdist = dist;
					useAltDmg = true;
				}
			}
			
			GetClientEyePosition(i, pos);
			dist = GetVectorDistance(pos, bl);
			if (dist <= radius)
			{
				Handle Tracing = TR_TraceRayFilterEx(bl, pos, MASK_SOLID, RayType_EndPoint, AllowPlayers, i);
				int index;
				index = TR_GetEntityIndex(Tracing);
				CloseHandle(Tracing);
				if (index == -1 || index == i)
				{
					float damage;
					damage = dmg * (radius - dist) / radius;
					bl[2] -= 32;
					PushDamagePlayer(i, damage, bl, pos, dist, radius);
				}
				else
				{
					float damage;
					if (useAltDmg && altdist < dist)
					{
						damage = (dmg * (radius - altdist) / radius) * 0.6;
						bl[2] -= 64;
						PushDamagePlayer(i, damage, bl, altpos, altdist, radius);
						continue;
					}
					damage = (dmg * (radius - dist) / radius) * 0.6;
					bl[2] -= 32;
					PushDamagePlayer(i, damage, bl, pos, dist, radius);
				}
			}
		}
	}
}

public bool AllowPlayers(int entity, int mask, any client)
{
	return entity >= 0 && entity <= MaxClients && entity == client;
}

int PushDamagePlayer(int client, float damage, float pos1[3], float pos2[3], float distance, float radius)
{
	float vel[3];
	MakeVectorFromPoints(pos1, pos2, vel);
	NormalizeVector(vel, vel);
	ScaleVector(vel, ((radius - distance) / radius) * GetConVarFloat(Pushscale));
	TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, vel);
	SDKHooks_TakeDamage(client, 0, 0, damage, DMG_BLAST);
}

public Action defuse(Handle timer, any client)
{	
	if (IsValidClient(client) && IsPlayerAlive(client))
	{
		
		float time = GetEngineTime() - PlantTimeF;
		PrintCenterText(client, "拆除炸弹中: %d%", RoundToFloor(time / defuseTime * 100.0));		
		if (time >= defuseTime)
		{
			SetEntityMoveType(client, MOVETYPE_WALK);
			PlantingClient = -1;
			PlantTimeF = 0.0;
			KillTimer(plantdefuse[client]);
			plantdefuse[client] = INVALID_HANDLE;
			RemoveBomb(2);		
				
		}
		TF2_RemoveCondition(client, TFCond_Ubercharged);
		TF2_RemoveCondition(client, TFCond_Disguised);
		TF2_RemoveCondition(client, TFCond_Bonked);
		TF2_RemoveCondition(client, TFCond_Cloaked);
		PrintToHudAll("%N 正在拆解炸弹!!!",client);				
	}
	
}

int RemoveBomb(int team)
{
	if (IsValidEdict(bomb))
	{
		char name[32];
		GetEntPropString(bomb, Prop_Data, "m_iName", name, sizeof(name));
		if (!strcmp("bomb", name))
		{
			AcceptEntityInput(bomb, "Kill");
		}
		bomb = -1;
	}
	if (RedWin != INVALID_HANDLE)
	{
		KillTimer(RedWin);
		PrintToHudAll("炸弹被拆除了, 红队获胜!");
		RedWin = INVALID_HANDLE;
	}
	if (BombTimer != INVALID_HANDLE)
	{
		KillTimer(BombTimer);
		BombTimer = INVALID_HANDLE;
	}
	BombLoc = NULL_VECTOR;
	SetWinningTeam(team);
	Planted = false;
	
}

int DropBomb(int client, bool discondeath=true, bool forcedrop=false)
{
	droppedbomb = CreateEntityByName("item_teamflag");//CreateEntityByName("prop_dynamic");
	
	if (IsValidEdict(droppedbomb))
	{
		float pos[3]; float endpos[3]; float ang[3];
		GetClientAbsOrigin(client, pos);
		DropPosition(pos, endpos);
		endpos[2] += 5;
		
		GetClientAbsAngles(client, ang);
		FixAngles(ang);
		TeleportEntity(droppedbomb, endpos, ang, NULL_VECTOR);
		endpos[2] -= 5;

		DispatchKeyValue(droppedbomb, "flag_model"/*"model"*/, BOMB1);
		DispatchKeyValue(droppedbomb, "skin", "2");
		DispatchKeyValue(droppedbomb, "targetname", "bomb");
		DispatchKeyValue(droppedbomb, "trail_effect", "0");

		DispatchSpawn(droppedbomb);
		
		SDKHook(droppedbomb, SDKHook_Touch, bombtouch);
		
		//SetEntityRenderColor(client);
		SetEntProp(client, Prop_Send, "m_bGlowEnabled", 0, 1);

		ClientWithBomb = -1;
		PlantingClient = -1;
		
		if (forcedrop)
		{
			PrintCenterText(client, "You have been forced to drop the bomb");
			PrintToHudAll("%N DROPPED the Bomb pick it or wait  %f seconds to random pickup", client, (GetConVarFloat(BombRetrieveTime)));
		}
		
		if (!discondeath)
		{
			BombDropper = client;
			CreateTimer(3.0, ResetDropper, BombDropper);
			
		}
			
		RestTimer = CreateTimer(GetConVarFloat(BombRetrieveTime), restorebomb);
		BombDropped = true;
		PrintToHudAll("%N 掉了炸弹", client, (GetConVarFloat(BombRetrieveTime)));
	}
}

public Action bombtouch(int entity, int other)
{
	if (!BombDropped || other <= 0 || other > MaxClients) return Plugin_Handled;
	
	if (IsValidClient(other) && IsPlayerAlive(other) && GetClientTeam(other) == 3 && other != BombDropper)
	{
		ClientWithBomb = other;
		SetEntProp(other, Prop_Send, "m_bGlowEnabled", 1, 1);
		//PrintToChatAll("\x03 %N \x01捡起了 \x03THE BOMB ", other);
		PrintToHudAll("%N 捡起了炸弹!", other);
		TF2_RemoveCondition(other, TFCond_Disguised);
		TF2_RemoveCondition(other, TFCond_Bonked);
		TF2_RemoveCondition(other, TFCond_Cloaked);
		if (IsValidEdict(droppedbomb))
		{
			char name[32];
			GetEntPropString(droppedbomb, Prop_Data, "m_iName", name, sizeof(name));
			if (!strcmp("bomb", name))
			{
				AcceptEntityInput(droppedbomb, "Kill");
				
			}
			droppedbomb = -1;
			//PrintToChatAll("\x03 %N \x01 DROPPED the Bomb pick it or wait \x03 %f \x01seconds for \x03Return Bomb in Base  ", other, (GetConVarFloat(BombRetrieveTime)));
			PrintToHudAll("%N 掉了炸弹!", other, (GetConVarFloat(BombRetrieveTime)));
			PrintToHud(other, "你捡起了炸弹, 在控制点上蹲下看地下按住右键来放置炸弹!");	
		}
		BombDropped = false;
		
		if (RestTimer != INVALID_HANDLE)
		{
			KillTimer(RestTimer);
			RestTimer = INVALID_HANDLE;
		}
	}
	return Plugin_Handled;
}

int DropPosition(float pos1[3], float pos2[3])
{
	float min[] = {-10.0, -10.0, 0.0};
	float max[] = {10.0, 10.0, 0.0};
	pos2 = pos1;
	pos2[2] -= 2048.0;
	Handle trace = TR_TraceHullFilterEx(pos1, pos2, min, max, MASK_SOLID, DisallowPlayers);
	TR_GetEndPosition(pos2, trace);
	CloseHandle(trace);
}

public bool DisallowPlayers(int entity, int mask)
{
	return entity > MaxClients;
}

int FixAngles(float ang[3])
{
	ang[1] -= 90.0;
	if (ang[1] < -180.0)
	{
		ang[1] += 360.0;
	}
	ang[0] = 0.0;
	ang[2] = -57.0;
}

public Action ResetDropper(Handle timer, any bombdropper)
{
	BombDropper = BombDropper == bombdropper ? -1 : BombDropper;
}

public Action restorebomb(Handle timer)
{
	if (IsValidEdict(droppedbomb))
	{
		char name[32];
		GetEntPropString(droppedbomb, Prop_Data, "m_iName", name, sizeof(name));
		if (!strcmp("bomb", name))
		{
			AcceptEntityInput(droppedbomb, "Kill");
		}
		droppedbomb = -1;
	}
	BombDropped = false;
	GiveBlueBomb();
	KillTimer(RestTimer);
	RestTimer = INVALID_HANDLE;
}

int GiveBlueBomb()
{
	int AliveBlueClients[MAXPLAYERS+1];
	int count = 0;
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsValidClient(i) && IsPlayerAlive(i) && !IsFakeClient(i) && GetClientTeam(i) == 3)
		{
			AliveBlueClients[count] = i;
			count++;
		}
	}
	if (count != 0)
	{
		int client = AliveBlueClients[GetRandomInt(0, count - 1)];
		ClientWithBomb = client;
		SetEntProp(client, Prop_Send, "m_bGlowEnabled", 1, 1);
		//SetEntityRenderColor(client, 0, 0, 0);
		//PrintCenterText(client, "You have the bomb!,USE CTRL+RIGHTCLICK+LOOK DOWN ON CP TO PLANT THE BOMB !!");					   
		//PrintToChatAll("\x03%N\x01 Picked \x03THE BOMB ", client);
		PrintToHudAll("%N 捡起了炸弹!", client);
		PrintToHud(client,"你捡起了炸弹,在控制点上蹲下看地下按住右键来放置炸弹!");
	}
	else
	{
		NooneHaveBomb = true;
	}
}

int SetWinningTeam(int team)
{
	int ent = -1;
	ent = FindEntityByClassname(-1, "team_control_point_master");

	if (ent == -1)
	{
		ent = CreateEntityByName("team_control_point_master");
		DispatchKeyValue(ent, "switch_teams", "1");
		DispatchSpawn(ent);
		AcceptEntityInput(ent, "Enable");
	}
	SetEntProp(ent, Prop_Data, "m_bSwitchTeamsOnWin", 1, 1);
	SetVariantInt(team);
	AcceptEntityInput(ent, "SetWinner");
}

public int HelpHandler(Menu menu, MenuAction action, int param1, int param2)
{
	if (action == MenuAction_Select)
	{		 
		switch (param2)
		{
			case 1: Case[param1]++;
			case 2: Case[param1]--;
			default:
			{
				ShowHelp[param1] = false;
				return;
			}
		}

		DisplayHelp(param1);
	}
	else if (action == MenuAction_Cancel)
	{
		ShowHelp[param1] = false;
	}
}

int DisplayHelp(int client)
{
	Handle panel = CreatePanel();
	int cse = Case[client];
	switch (cse)
	{
		case 1:
		{
			SetPanelTitle(panel, "目标");
			DrawPanelText(panel, "蓝队获胜目标是 \n在控制点上放置炸弹, \n红队需要防守炸弹 \n或者拆除炸弹.\n");
		}
		case 0:
		{
			SetPanelTitle(panel, "放置/拆除炸弹");
			DrawPanelText(panel, "先确定你有没有炸弹 \n, 然后蹲在 \n控制点上, 看下面 \n并按住 +attack2按钮 (就是鼠标右键), \n拆除炸弹也是一样的步骤.\n");
		}
		case 2:
		{
			SetPanelTitle(panel, "扔炸弹");
			DrawPanelText(panel, "你可以通过 \ndropitem 命令来丢炸弹 (就是l键, 和 \n丢情报的键是一样的).\n");
		}
	}

	if (cse != 2)
	{
		DrawPanelItem(panel, "下一页");
	}
	else
	{
		DrawPanelItem(panel, "下一页", ITEMDRAW_DISABLED);
	}
	if (cse != 0)
	{
		DrawPanelItem(panel, "返回", ITEMDRAW_CONTROL);
	}
	else
	{
		DrawPanelItem(panel, "返回", ITEMDRAW_DISABLED);
	}
	DrawPanelItem(panel, "退出", ITEMDRAW_CONTROL);
	SendPanelToClient(panel, client, HelpHandler, 20);
	CloseHandle(panel);
}
int UpdateGameDescription(bool bAddOnly=false)
{
	if (g_bSteamTools)
	{
		char gamemode[64];
		if (GetConVarBool(g_Cvar_GameDescription))
		{
			Format(gamemode, sizeof(gamemode), "Bomb Fortress v.%s", PLUGIN_VERSION);
		}
		else if (bAddOnly)
		{
			
			return;
		}
		else
		{
			strcopy(gamemode, sizeof(gamemode), "Team Fortress");
		}
		Steam_SetGameDescription(gamemode);
	}
}
public Action SoundHook(int clients[64], int &numClients, char sound[PLATFORM_MAX_PATH], int &Ent, int &channel, float &volume, int &level, int &pitch, int &flags)
{
	for (int i = 1; i <= MaxClients; i++){
		if (StrContains(sound, "player/footsteps/", false) != -1 && ClientWithBomb == i){
			 TF2_RemoveCondition(i, TFCond_Ubercharged);
			 TF2_RemoveCondition(i, TFCond_Disguised);
			 TF2_RemoveCondition(i, TFCond_Bonked);
			 TF2_RemoveCondition(i, TFCond_Cloaked);
			
		}
	}
	return Plugin_Continue;
}

stock bool IsValidClient(int iClient) {
	if (iClient <= 0) return false;
	if (iClient > MaxClients) return false;
	if (!IsClientConnected(iClient)) return false;
	return IsClientInGame(iClient);
}
stock int TF2_GetNameOfClass(TFClassType class, char[] name, int maxlen)
{
	switch (class)
	{
		case TFClass_Scout: Format(name, maxlen, "scout");
		case TFClass_Soldier: Format(name, maxlen, "soldier");
		case TFClass_Pyro: Format(name, maxlen, "pyro");
		case TFClass_DemoMan: Format(name, maxlen, "demoman");
		case TFClass_Heavy: Format(name, maxlen, "heavy");
		case TFClass_Engineer: Format(name, maxlen, "engineer");
		case TFClass_Medic: Format(name, maxlen, "medic");
		case TFClass_Sniper: Format(name, maxlen, "sniper");
		case TFClass_Spy: Format(name, maxlen, "spy");
	}
}
int SetClientOverlay(int client, char[] strOverlay)
{
	if(IsValidClient(client)){
		int iFlags = GetCommandFlags("r_screenoverlay") & (~FCVAR_CHEAT);
		SetCommandFlags("r_screenoverlay", iFlags);	
		ClientCommand(client, "r_screenoverlay \"%s\"", strOverlay);
	}
}
public void OnMapEnd()
{
	ServerCommand("bombfortress_gamedescription 0");
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsValidClient(i) && (!(IsFakeClient(i))))
		{
			SetClientOverlay(i,"");
		}
	}
}