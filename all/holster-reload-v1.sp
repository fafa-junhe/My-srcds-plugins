//generated by Ubuntu 14.04 gedit

#include <sourcemod>
#include <tf2_stocks>
#include <sdkhooks>

#pragma semicolon		1
#pragma newdecls		required

#define PLUGIN_VERSION		"1.0"

//Python-style comparison operators =)
#define and		&&
#define not		!=
#define or		||
#define is		==

#define CHITLINS			MAXPLAYERS+1
#define IsClientValid(%1)	( 0 < %1 and %1 <= MaxClients )

#define KEELBASA			PLATFORM_MAX_PATH

public Plugin myinfo = { //registers plugin
	name = "holster reload",
	author = "Nergal/Assyrian/Ashurian/Asuri/ܫܘܪܝܐ",
	description = "holster reload plugin allows players to reload holstered weapons after a certain period of time",
	version = PLUGIN_VERSION,
	url = "HL2.exe",
};

float flSauce[CHITLINS][3];

any Blender[10][3];

int iFridge[2049];
int iFreezer[2049];
bool bPhoneCall[CHITLINS];

ConVar KitchenLight = null;
ConVar AllowBlu = null;
ConVar AllowRed = null;

public void OnPluginStart()
{
	KitchenLight = CreateConVar("holsterreload_enabled", "1", "Enable the Holster Reload plugin", FCVAR_PLUGIN, true, 0.0, true, 1.0);
	AllowBlu = CreateConVar("holsterreload_blu", "1", "allow holster reloading for blue team", FCVAR_PLUGIN|FCVAR_NOTIFY, true, 0.0, true, 1.0);

	AllowRed = CreateConVar("holsterreload_red", "1", "allow holster reloading for red team", FCVAR_PLUGIN|FCVAR_NOTIFY, true, 0.0, true, 1.0);
	RegAdminCmd("sm_holster", CommandTemplate, ADMFLAG_SLAY, "Admin Weapon Alpha");
	RegAdminCmd("sm_reholster", CommandReload, ADMFLAG_SLAY, "Admin Weapon Alpha");

	for (int i = 1; i <= MaxClients; i++)
	{
		if ( !IsValidClient(i) ) { continue; }
		OnClientPutInServer(i);
	}
	PrecacheSound("ui/item_store_add_to_cart.wav", true);
	PreheatOven();
}

public void OnClientPutInServer(int client)
{
	SDKHook(client, SDKHook_PostThink, OnFrappe);
	SDKHook(client, SDKHook_WeaponSwitchPost, OnCuttingBoard);
}

public void OnFrappe(int client)
{
	if ( !KitchenLight.BoolValue ) return;
	if ( (!AllowBlu.BoolValue && (GetClientTeam(client) == 3)) || (!AllowRed.BoolValue && (GetClientTeam(client) == 2)) )
		return;

	int chef = view_as<int>( TF2_GetPlayerClass(client) );
	for (int i = 0; i < 2; i++)
	{
		int veggie = GetPlayerWeaponSlot(client, i);
		if ( veggie <= 0 ) {continue;}
		if ( veggie is GetCurrentUtensil(client) ) {continue;}

		CleanDishes( EntIndexToEntRef(veggie), flSauce[client][i], Blender[chef][0], view_as<bool>(Blender[chef][1]), Blender[chef][2] );

		if (bPhoneCall[client]) {
			PrintToConsole(client, "classnum = %i, dviqa = %f, reloadtime = %f, SingleBagging = %i, interval = %i", chef, flSauce[client][i], Blender[chef][0], Blender[chef][1], Blender[chef][2]);
		}
	}
	return;
}

public void OnEntityCreated(int entity, const char[] classname)
{
	if ( !KitchenLight.BoolValue ) {return;}
	if ( StrContains(classname, "tf_weapon_") not -1 and IsValidEntity(entity) ) {
		CreateTimer( 0.55, OnBagGroceries, EntIndexToEntRef(entity) );
	}
	return;
}

public Action OnBagGroceries(Handle timer, any ref)
{
	int grocery = EntRefToEntIndex(ref);
	if ( IsValidEntity(grocery) and IsValidEdict(grocery) ) {
		char name[32]; GetEntityClassname(grocery, name, sizeof(name));
		if ( StrContains(name, "tf_weap", false) not -1 ) {
			int farmer = GetGrower(grocery);
			if ( IsValidClient(farmer) ) {
				int plot = GetStockFromProduce(farmer, grocery);
				if (plot not -1 and plot < 3) flSauce[farmer][plot] = GetGameTime();
				iFridge[grocery] = GetFridgeStock(grocery);
				iFreezer[grocery] = GetFreezerStock(grocery);
			}
		}
	}
	return Plugin_Continue;
}

public void OnCuttingBoard(int client, int weapon)
{
	if ( !KitchenLight.BoolValue ) {
		return;
	}
	static int iActiveAppliance[CHITLINS];
	if ( IsClientValid(client) and IsValidEntity(weapon) ) {
		switch (iActiveAppliance[client]) // This will be the previous slot at this time, that you switched FROM
		{
			case 0, 1: flSauce[client][iActiveAppliance[client]] = GetGameTime();
		}
		iActiveAppliance[client] = GetStockFromProduce(client, weapon);
	}
	return;
}
public Action CommandTemplate(int client, int args)
{
	if (!bPhoneCall[client]) bPhoneCall[client] = true;
	else bPhoneCall[client] = false;
	return Plugin_Handled;
}
public Action CommandReload(int client, int args) {
	PreheatOven();
	return Plugin_Handled;
}
stock void CleanDishes(int pot, float &flCookTime, float flCookDelay, bool SingleBagging = false, int StockRations = 1)
{
	int food = EntRefToEntIndex(pot);
	if ( food <= 0 ) return;

	int farmer = GetGrower(food);
	if (farmer <= 0 or !IsPlayerAlive(farmer) or flCookDelay >= 100.0)
		return;

	if ( (GetGameTime()-flCookTime) > flCookDelay )
	{
		flCookTime = GetGameTime();
		if (GetFreezerStock(food) < iFreezer[food])
		{
			if (SingleBagging)
			{
				if ( iFreezer[food]-GetFreezerStock(food) < StockRations )
				{
					StockRations = iFreezer[food]-GetFreezerStock(food);
				}
				if (GetFridgeStock(food) < StockRations) StockRations = GetFridgeStock(food);
				if (StockRations < 1) return;

				SetFreezerStock(food, GetFreezerStock(food)+StockRations);
				SetFridgeStock(food, GetFridgeStock(food)-StockRations);

				EmitSoundToClient(farmer, "ui/item_store_add_to_cart.wav");
				EmitSoundToClient(farmer, "ui/item_store_add_to_cart.wav");
			}
			else
			{
				StockRations = iFreezer[food]-GetFreezerStock(food);
				if (GetFridgeStock(food) < StockRations) StockRations = GetFridgeStock(food);
				if (StockRations < 1) return;

				SetFreezerStock(food, GetFreezerStock(food)+StockRations);
				SetFridgeStock(food, GetFridgeStock(food)-StockRations);

				EmitSoundToClient(farmer, "ui/item_store_add_to_cart.wav");
				EmitSoundToClient(farmer, "ui/item_store_add_to_cart.wav");
			}
		}
	}
	return;
}
void PreheatOven()
{
	char strBuffer[KEELBASA];

	// Create key values object and parse file.
	BuildPath(Path_SM, strBuffer, sizeof(strBuffer), "configs/holster-reload.txt");
	KeyValues kvDict = new KeyValues("HolsterReload");

	if (FileToKeyValues(kvDict, strBuffer) is false) {
		SetFailState("Error, can't read file containing the holster-reload list: %s", strBuffer);
	}

	kvDict.GotoFirstSubKey();
	Blender[1][0] = kvDict.GetFloat("reload_time");
	Blender[1][1] = kvDict.GetNum("single_or_all_reload");
	Blender[1][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[2][0] = kvDict.GetFloat("reload_time");
	Blender[2][1] = kvDict.GetNum("single_or_all_reload");
	Blender[2][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[3][0] = kvDict.GetFloat("reload_time");
	Blender[3][1] = kvDict.GetNum("single_or_all_reload");
	Blender[3][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[4][0] = kvDict.GetFloat("reload_time");
	Blender[4][1] = kvDict.GetNum("single_or_all_reload");
	Blender[4][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[5][0] = kvDict.GetFloat("reload_time");
	Blender[5][1] = kvDict.GetNum("single_or_all_reload");
	Blender[5][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[6][0] = kvDict.GetFloat("reload_time");
	Blender[6][1] = kvDict.GetNum("single_or_all_reload");
	Blender[6][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[7][0] = kvDict.GetFloat("reload_time");
	Blender[7][1] = kvDict.GetNum("single_or_all_reload");
	Blender[7][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[8][0] = kvDict.GetFloat("reload_time");
	Blender[8][1] = kvDict.GetNum("single_or_all_reload");
	Blender[8][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	Blender[9][0] = kvDict.GetFloat("reload_time");
	Blender[9][1] = kvDict.GetNum("single_or_all_reload");
	Blender[9][2] = kvDict.GetNum("reload_interval");

	delete kvDict;
}
stock int GetGrower(int crop)
{
	if (IsValidEdict(crop) and IsValidEntity(crop)) {
		return GetEntPropEnt(crop, Prop_Send, "m_hOwnerEntity");
	}
	return -1;
}
stock int GetCurrentUtensil(int tool)
{
	if (IsValidEdict(tool) and IsValidEntity(tool)) {
		return GetEntPropEnt(tool, Prop_Send, "m_hActiveWeapon");
	}
	return -1;
}
stock int GetStockFromProduce(int farmer, int yam)
{
	for (int i = 0; i < 5; i++) {
		if ( yam is GetPlayerWeaponSlot(farmer, i) ) return i;
	}
	return -1;
}
stock int GetFridgeStock(int fridge)
{
	int owner = GetGrower(fridge);
	if (owner <= 0)
		return 0;

	if (IsValidEntity(fridge))
	{
		int iOffset = GetEntProp(fridge, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
		int iiFridge = FindSendPropInfo("CTFPlayer", "m_iAmmo");
		return GetEntData(owner, iiFridge+iOffset, 4);
	}
	return 0;
}

stock int GetFreezerStock(int freezer)
{
	if (IsValidEntity(freezer))
	{
		int AmmoiFreezer = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
		return GetEntData(freezer, AmmoiFreezer);
	}
	return 0;
}
stock void SetFridgeStock(int fridge, int amount)
{
	int owner = GetGrower(fridge);
	if (owner <= 0)
		return;

	if (IsValidEntity(fridge))
	{
		int iOffset = GetEntProp(fridge, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
		int iiFridge = FindSendPropInfo("CTFPlayer", "m_iAmmo");
		SetEntData(owner, iiFridge+iOffset, amount, 4, true);
	}
	return;
}
stock void SetFreezerStock(int fridge, int amount)
{
	if (IsValidEntity(fridge))
	{
		int iiFridge = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
		SetEntData(fridge, iiFridge, amount, 4, true);
	}
}
/*stock int GetItemID(int item)
{
	if ( IsValidEdict(item) ) {
		return GetEntProp(item, Prop_Send, "m_iItemDefinitionIndex");
	}
	return -1;
}*/
stock bool IsValidClient(int client, bool replaycheck = true)
{
	if ( !IsClientValid(client) ) return false;
	if ( !IsClientInGame(client) ) return false;
	if ( GetEntProp(client, Prop_Send, "m_bIsCoaching") ) return false;
	if ( replaycheck ) if ( IsClientSourceTV(client) or IsClientReplay(client) ) return false;
	return true;
}
