/* Plugin Template generated by Pawn Studio
* 				Because I'm Pro!			 */

#pragma semicolon 1

#include <sourcemod>
#include <sdktools>
#include <tf2>
#include <tf2_stocks>

#define PLUGIN_VERSION			"0.2"

#define ITEMARRAY_SLOT			0
#define ITEMARRAY_LEVEL			1
#define ITEMARRAY_QUALITY		2
#define ITEMARRAY_USED			3

#define CVAR_VERSION			0
#define CVAR_CONFIG				1
#define CVAR_ENABLE				2
#define NUM_CVARS				3

new Handle:g_cvars[NUM_CVARS] = INVALID_HANDLE;
new Handle:g_config = INVALID_HANDLE;
new g_items[MAXPLAYERS+1][4]; 

public Plugin:myinfo = 
{
	name = "Weapon Adjuster",
	author = "Jindo",
	description = "Adjust the level and rarity of weapons owned by players.",
	version = PLUGIN_VERSION,
	url = "http://www.topaz-games.com/"
}

public OnPluginStart()
{
	LoadTranslations("weaponalter.phrases");
	LoadTranslations("core.phrases");
	
	g_cvars[CVAR_VERSION] = CreateConVar("weaponadjuster_version", PLUGIN_VERSION, "Weapon Adjuster version.", FCVAR_PLUGIN|FCVAR_REPLICATED);
	g_cvars[CVAR_CONFIG] = CreateConVar("wa_configfile", "configs/wadjust.cfg", "File path to the config, relative to the sourcemod folder.", FCVAR_PLUGIN);
	g_cvars[CVAR_ENABLE] = CreateConVar("wa_enable", "1", "Non-zero enables the plugin.", FCVAR_PLUGIN);
	
	RegAdminCmd("wa_reload", Command_Reload, ADMFLAG_ROOT);
	RegAdminCmd("wa_setweapons", Command_SetWeapons, ADMFLAG_ROOT);
	RegAdminCmd("wa_setweapon", Command_SetWeapon, ADMFLAG_ROOT);
	RegAdminCmd("wa_unsetweapons", Command_UnsetWeapons, ADMFLAG_ROOT);
	RegAdminCmd("wa_hideinfo", Command_HideWeaponInfoSlot, ADMFLAG_ROOT);
	//RegAdminCmd("wa_hideall", Command_HideWeaponInfoAll, ADMFLAG_ROOT); I Will Finish This Part Later
	
	//HookEvent("player_spawn", Event_CheckWeapons);
	HookEvent("post_inventory_application", Event_CheckWeapons);
	
	LoadConfig();
}

public OnMapStart()
{
	for (new i = 1; i < MAXPLAYERS+1; i++)
	{
		g_items[i][ITEMARRAY_USED] = 0;
	}
}

/* Command_SetWeapon
* Console command to change the info of a player's weapon.
*/
public Action:Command_SetWeapon(client, args)
{
	if (args < 4)
	{
		ReplyToCommand(client, "[AW] Usage: wa_setweapon <client> <slot> <level> <quality>");
		return Plugin_Handled;
	}
	
	decl String:name[64], String:str_slot[64], String:str_level[64], String:str_quality[64];
	
	GetCmdArg(1, name, sizeof(name));
	GetCmdArg(2, str_slot, sizeof(str_slot));
	GetCmdArg(3, str_level, sizeof(str_level));
	GetCmdArg(4, str_quality, sizeof(str_quality));
	
	new slot = StringToInt(str_slot);
	new level = StringToInt(str_level);
	new rarity = StringToInt(str_quality);
	
	if (rarity < 1 || rarity > 6)
	{
		ReplyToCommand(client, "[AW] Invalid rarity.");
		return Plugin_Handled;
	}
	
	if (level < 0)
	{
		level = 0;
	}
	if (level > 100) // Since it defaults to 57 otherwise, I'd better
	{				 // take it in to my own hands.
		level = 100;
	}
	
	decl String:target_name[MAX_TARGET_LENGTH];
	decl target_list[MAXPLAYERS], target_count, bool:tn_is_ml;
	
	if ((target_count = ProcessTargetString(
			name,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_ALIVE,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	for (new i = 0; i < target_count; i++)
	{
		SetClientWeapon(target_list[i], slot, level, rarity);
	}
	
	if (tn_is_ml)
	{
		ShowActivity2(client, "[AW] ", "%t", "Changed item", target_name);
	}
	else
	{
		ShowActivity2(client, "[AW] ", "%t", "Changed item", "_s", target_name);
	}
	
	return Plugin_Handled;
}

/* Command_SetWeapons
* Console command to change the info of a player's weapons.
*/
public Action:Command_SetWeapons(client, args)
{
	if (args < 3)
	{
		ReplyToCommand(client, "[AW] Usage: wa_setweapons <client> <level> <quality>");
		return Plugin_Handled;
	}
	
	decl String:name[64], String:str_level[64], String:str_quality[64];
	
	GetCmdArg(1, name, sizeof(name));
	GetCmdArg(2, str_level, sizeof(str_level));
	GetCmdArg(3, str_quality, sizeof(str_quality));
	
	new level = StringToInt(str_level);
	new rarity = StringToInt(str_quality);
	
	if (rarity < 1 || rarity > 6)
	{
		ReplyToCommand(client, "[AW] Invalid rarity.");
		return Plugin_Handled;
	}
	
	if (level < 0)
	{
		level = 0;
	}
	if (level > 100) // Since it defaults to 57 otherwise, I'd better
	{				 // take it in to my own hands.
		level = 100;
	} //cnpftw
	
	decl String:target_name[MAX_TARGET_LENGTH];
	decl target_list[MAXPLAYERS], target_count, bool:tn_is_ml;
	
	if ((target_count = ProcessTargetString(
			name,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_ALIVE,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	for (new i = 0; i < target_count; i++)
	{
		SetClientWeapon(target_list[i], -1, level, rarity);
	}
	
	if (tn_is_ml)
	{
		ShowActivity2(client, "[AW] ", "%t", "Changed loadout", target_name);
	}
	else
	{
		ShowActivity2(client, "[AW] ", "%t", "Changed loadout", "_s", target_name);
	}
	
	return Plugin_Handled;
}

/* Command_UnsetWeapons
* Console command to reset the info of a player's weapons.
*/
public Action:Command_UnsetWeapons(client, args)
{
	if (args < 1)
	{
		ReplyToCommand(client, "[AW] Usage: wa_unsetweapons <client>");
		return Plugin_Handled;
	}
	
	decl String:name[64];
	
	GetCmdArg(1, name, sizeof(name));
	
	decl String:target_name[MAX_TARGET_LENGTH];
	decl target_list[MAXPLAYERS], target_count, bool:tn_is_ml;
	
	if ((target_count = ProcessTargetString(
			name,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_ALIVE,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	for (new i = 0; i < target_count; i++)
	{
		g_items[target_list[i]][ITEMARRAY_USED] = 0;
	}
	
	if (tn_is_ml)
	{
		ShowActivity2(client, "[AW] ", "%t", "Reset loadout", target_name);
	}
	else
	{
		ShowActivity2(client, "[AW] ", "%t", "Reset loadout", "_s", target_name);
	}
	
	return Plugin_Handled;
}

/* Command_HideWeaponInfoAll {{{
* Console command to hide a player's weapons' info.
*//* I Will Finish This Part Later
public Action:Command_HideWeaponInfoAll(client, args)
{
	if (args < 1)
	{
		ReplyToCommand(client, "[WA] Usage: wa_hideall <client>");
		return Plugin_Handled;
	}
	
	decl String:name[64];
	GetCmdArg(1, name, sizeof(name));
	
	decl String:target_name[MAX_TARGET_LENGTH];
	decl target_list[MAXPLAYERS], target_count, bool:tn_is_ml;
	
	if ((target_count = ProcessTargetString(
			name,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_ALIVE,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	for (new i = 0; i < target_count; i++)
	{
		PerformHideAllWeapons(target_list[i]);
	}
	
	if (tn_is_ml)
	{
		ShowActivity2(client, "[AW] ", "%t", "Hid loadout", target_name);
	}
	else
	{
		ShowActivity2(client, "[AW] ", "%t", "Hid loadout", "_s", target_name);
	}
	
	return Plugin_Handled;
}
// }}} Command_HideWeaponInfoAll
*/
/* Command_HideWeaponInfoSlot {{{
* Console command to hide all weapons' inspection bars
*/
public Action:Command_HideWeaponInfoSlot(client, args)
{
	if (args < 2)
	{
		ReplyToCommand(client, "[WA] Usage: wa_hideinfo <client> <slot>");
		return Plugin_Handled;
	}
	
	decl String:name[64];
	GetCmdArg(1, name, sizeof(name));
	decl String:slot[16];
	GetCmdArg(2, slot, sizeof(slot));
	
	new islot = StringToInt(slot);
	
	decl String:target_name[MAX_TARGET_LENGTH];
	decl target_list[MAXPLAYERS], target_count, bool:tn_is_ml;
	
	if ((target_count = ProcessTargetString(
			name,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_ALIVE,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	for (new i = 0; i < target_count; i++)
	{
		PerformHideWeapon(target_list[i], islot);
	}
	
	if (tn_is_ml)
	{
		ShowActivity2(client, "[AW] ", "%t", "Hid weapon", target_name, islot);
	}
	else
	{
		ShowActivity2(client, "[AW] ", "%t", "Hid weapon", "_s", target_name, islot);
	}
	
	return Plugin_Handled;
}
// }}} Command_HideWeaponInfoSlot

/* Command_Reload {{{
* Console command to reload the config.
*/
public Action:Command_Reload(client, args)
{
	LoadConfig();
	decl String:configString[128];
	GetConVarString(g_cvars[CVAR_CONFIG], configString, sizeof(configString));
	ReplyToCommand(client, "[AW] %t", "Config refresh", configString);
	return Plugin_Handled;
}
// }}} Command_Reload

/* Event_CheckWeapons {{{
* Runs through the necessary checks to see if the desired target
* matches the conditions. If the target matches the conditions,
* change the desired weapon to the chosen level and quality.
*/
public Action:Event_CheckWeapons(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!GetConVarBool(g_cvars[CVAR_ENABLE]))
	{
		return Plugin_Continue;
	}
	if (g_config == INVALID_HANDLE)
	{
		LogError("Fatal: config not loaded");
		SetFailState("Fatal: config not loaded");
	}
	KvRewind(g_config);
	new nodes;
	if ((nodes = KvGetNum(g_config, "max_nodes", -1)) < 0)
	{
		LogError("Fatal: max_nodes not specified.");
		SetFailState("Fatal: max_nodes not specified.");
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid")), rarity, weplvl, wep;
	decl String:sid[64], String:cname[64], String:class[64], String:flags[64], String:istr[4];
	for (new i = 1; i <= nodes; i++)
	{
		IntToString(i, istr, sizeof(istr));
		if (!KvJumpToKey(g_config, istr))
		{
			LogError("Warning: Invalid node %i.", i);
			return Plugin_Continue;
		}
		KvGetString(g_config, "steamid_eq", sid, sizeof(sid), "any");
		KvGetString(g_config, "name_contains", cname, sizeof(cname), "any");
		KvGetString(g_config, "class_eq", class, sizeof(class), "any");
		KvGetString(g_config, "flags", flags, sizeof(flags), "_");
		rarity = KvGetNum(g_config, "rarity", 3);
		weplvl = KvGetNum(g_config, "level", 1);
		wep = KvGetNum(g_config, "slot", -1);
		CompareDetails(client, i, wep, sid, cname, class, flags, weplvl, rarity);
		KvRewind(g_config);
	}
	if (g_items[client][ITEMARRAY_USED] == 1)
	{
		SetClientWeaponData(client);
	}
	return Plugin_Continue;
}
// }}} Event_CheckWeapons

/* CompareDetails {{{
* Takes several pieces of information and compares them against that
* of the client's. If there are no mismatches, change the specified
* weapon slot's weapon's level and rarity to the ones specified.
* 
* @param	client			client id to compare against
* @param	id				id of the config node for debugging
* @param	wep				weapon slot to change
* @param	sid				steam id to compare
* @param	cname			optional name to compare
* @param	class			optional class to compare
* @param	flags			optional flags to compare
* @param	level			weapon level to set
* @param	quality			weapon quality to set
* 
* @return	true on full match, false otherwise.
*/
stock bool:CompareDetails(client, id, wep, const String:sid[64], const String:cname[64], const String:class[64], const String:flags[64], level, quality)
{
	if (g_items[client][ITEMARRAY_USED] == 1 || client == 0 || !IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return false;
	}
	
	decl String:clientAuth[64], String:clientName[64];
	GetClientAuthString(client, clientAuth, sizeof(clientAuth));
	GetClientName(client, clientName, sizeof(clientName));
	
	if (strcmp(clientAuth, sid, true) != 0 && strcmp(sid, "any", true) != 0)
	{
		return false;
	}
	
	if (StrContains(clientName, cname, false) == -1 && strcmp(cname, "any", true) != 0)
	{
		return false;
	}
	
	if (TF2_GetPlayerClass(client) != TF2_GetClass(class) && strcmp(class, "any", true) != 0)
	{
		return false;
	}
	
	if (!CompareAdminFlags(client, flags))
	{
		return false;
	}
	
	if (wep != -1)
	{
		new ent = GetPlayerWeaponSlot(client, wep);
		if (ent != -1)
		{
			if (level != -1)
			{
				SetEntProp(ent, Prop_Send, "m_iEntityLevel", level);
			}
			if (quality > 0 && quality < 7)
			{
				SetEntProp(ent, Prop_Send, "m_iEntityQuality", quality);
			}
			else
			{
				LogError("Warning: invalid quality, must be between 1 and 6 inclusive.");
				return false;
			}
		}
	}
	else
	{
		for (new i = 0; i < 5; i++)
		{
			new ent = GetPlayerWeaponSlot(client, i);
			if (ent != -1)
			{
				if (level != -1)
				{
					SetEntProp(ent, Prop_Send, "m_iEntityLevel", level);
				}
				if (quality > 0 && quality < 7)
				{
					SetEntProp(ent, Prop_Send, "m_iEntityQuality", quality);
				}
				else
				{
					LogError("Warning: invalid quality, must be between 1 and 6 inclusive.");
					return false;
				}
			}
		}
	}
	
	return true;
}

/* LoadConfig {{{
* Reloads the config.
*/
stock LoadConfig()
{
	decl String:filepath[128];
	GetConVarString(g_cvars[CVAR_CONFIG], filepath, sizeof(filepath));
	BuildPath(Path_SM, filepath, sizeof(filepath), "%s", filepath);
	
	if (g_config != INVALID_HANDLE)
	{
		CloseHandle(g_config);
		g_config = INVALID_HANDLE;
	}
	
	g_config = CreateKeyValues("weapons");
	if (!FileToKeyValues(g_config, filepath))
	{
		LogError("Fatal: Config file \"%s\" not found. Make sure the file exists and is relative to your sourcemod folder.", filepath);
		SetFailState("Missing config.");
	}
}
// }}} LoadConfig

/* CompareAdminFlags {{{
* Compares a client's admin flags against the specified.
* 
* @param	client			client to compare against
* @param	flags			flags to compare with
* 
* @return	true on match, false otherwise.
*/
stock bool:CompareAdminFlags(client, const String:flags[])
{
	if (strcmp(flags, "_", true) == 0)
	{
		return true;
	}
	if (GetUserFlagBits(client) & ADMFLAG_ROOT)
	{
		return true;
	}
	new iFlags = ReadFlagString(flags);
	if (GetUserFlagBits(client) & iFlags)
	{
		return true;
	}
	return false;
}
// }}} CompareAdminFlags

/* PerformHideWeapon {{{
* Adjusts a weapon's data to prevent the inspect bar from appearing.
* 
* @param	client		Targeted player
* @param	slot		Targeted slot
* 
* @noreturn
*/
PerformHideWeapon(client, slot)
{
	if (client == 0 || !IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return;
	}
	
	new ent = GetPlayerWeaponSlot(client, slot);
	SetEntProp(ent, Prop_Send, "m_iEntityQuality", 0);
	g_items[client][ITEMARRAY_SLOT] = slot;
	g_items[client][ITEMARRAY_QUALITY] = 0;
	g_items[client][ITEMARRAY_USED] = 1;
}

/* PerformHideAllWeapons {{{
* Adjusts all weapons data to prevent the inspect bar from appearing.
* 
* @param	client		Targeted player
* 
* @noreturn
*//*I Will Finish This Part Later
PerformHideAllWeapons(client)
{
	if (client == 0 || !IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return;
	}
	
	for (new i = 0; i < 5; i++)
	{
		new ent = GetPlayerWeaponSlot(client, i);
		SetEntProp(ent, Prop_Send, "m_iEntityQuality", 0);
	}
	g_items[client][ITEMARRAY_SLOT] = -1;
	g_items[client][ITEMARRAY_QUALITY] = 0;
	g_items[client][ITEMARRAY_USED] = 1;
}*/
/* SetClientWeapon
* If a client's weapons have been adjusted manually via a command, 
* this enforces that setting so that conditions do not interfere
* with it.
* 
* @param	client		Targeted player.
* @param	slot		Slot to change
* @param	level		Level to set
* @param	rarity		Rarity to set
* 
* @noreturn
*/
SetClientWeapon(client, slot, level, rarity)
{
	if (client == 0 || !IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return;
	}
	if (slot == -1)
	{
		for (new i = 0; i < 5; i++)
		{
			new ent = GetPlayerWeaponSlot(client, i);
			if (level != -1)
			{
				SetEntProp(ent, Prop_Send, "m_iEntityLevel", level);
				g_items[client][ITEMARRAY_LEVEL] = level;
			}
			if (rarity != -1)
			{
				SetEntProp(ent, Prop_Send, "m_iEntityQuality", rarity);
				g_items[client][ITEMARRAY_QUALITY] = rarity;
			}
			g_items[client][ITEMARRAY_SLOT] = -1;
			g_items[client][ITEMARRAY_USED] = 1;
			return;
		}
	}
	else
	{
		new ent = GetPlayerWeaponSlot(client, slot);
		if (level != -1)
		{
			SetEntProp(ent, Prop_Send, "m_iEntityLevel", level);
			g_items[client][ITEMARRAY_LEVEL] = level;
		}
		if (rarity != -1)
		{
			SetEntProp(ent, Prop_Send, "m_iEntityQuality", rarity);
			g_items[client][ITEMARRAY_QUALITY] = rarity;
		}
		g_items[client][ITEMARRAY_USED] = 1;
		g_items[client][ITEMARRAY_SLOT] = slot;
		return;
	}
}

/* SetClientWeaponData
* If a client's weapons have been adjusted manually via a command, 
* this enforces that setting so that conditions do not interfere
* with it.
* 
* @param	client		Targeted player.
* 
* @noreturn
*/
SetClientWeaponData(client)
{
	if (g_items[client][ITEMARRAY_USED] == 0 || client == 0 || !IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return;
	}
	if (g_items[client][ITEMARRAY_SLOT] == -1)
	{
		for (new i = 0; i < 5; i++)
		{
			new ent = GetPlayerWeaponSlot(client, i);
			SetEntProp(ent, Prop_Send, "m_iEntityQuality", g_items[client][ITEMARRAY_QUALITY]);
			SetEntProp(ent, Prop_Send, "m_iEntityLevel", g_items[client][ITEMARRAY_LEVEL]);
		}
	}
	else
	{
		new ent = GetPlayerWeaponSlot(client, g_items[client][0]);
		SetEntProp(ent, Prop_Send, "m_iEntityQuality", g_items[client][ITEMARRAY_QUALITY]);
		SetEntProp(ent, Prop_Send, "m_iEntityLevel", g_items[client][ITEMARRAY_LEVEL]);
	}
}