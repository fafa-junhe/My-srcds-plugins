/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks>
 
#define Pai 3.14159265358979323846 
 
#define action_normal 1
#define action_tracing 2
  

new ReplaceWitchId=0;
new Float:ReplaceWitchTime;
new Float:ReplaceWitchPos[3];
new Float:ReplaceWitchAngle[3];
new Float:ReplaceWitchRage;
new Float:ReplaceWitchWanderRage;
new Float:ReplaceWitchScale;
new ReplaceWitchRush;
new ReplaceWitchFlag;
new ReplaceWitchSequence;
new ReplaceWitchVictim;

new HookWitchCount=0;
 
public Plugin:myinfo = 
{
	name = "Evil Witch",
	author = "Pan XiaoHai",
	description = "<- Description ->",
	version = "1.8",
	url = "<- URL ->"
}

new Handle:l4d_witch_range_vision= INVALID_HANDLE; 
new Handle:l4d_witch_attack_range= INVALID_HANDLE;
new Handle:l4d_witch_chance_attacknext= INVALID_HANDLE;
new Handle:l4d_witch_chance_followsurvivor= INVALID_HANDLE;
new Handle:l4d_witch_changetarget= INVALID_HANDLE;

new GameMode;
new L4D2Version;
new g_sprite;
public OnPluginStart()
{
	GameCheck(); 

	l4d_witch_chance_attacknext = CreateConVar("l4d_witch_chance_attacknext", "100.0", "chance of continue attack [0.0, 100.0]" );
	l4d_witch_changetarget = CreateConVar("l4d_witch_changetarget", "1", "0:do not change target when witch attack victim to incapacitated, 1:change target");
	l4d_witch_attack_range = CreateConVar("l4d_witch_attack_range", "400.0", "after attacking, witch will attack someone in this range, can not set too big, or witch will run away");


	l4d_witch_chance_followsurvivor = CreateConVar("l4d_witch_chance_followsurvivor", "60.0", " chance of fellow survivors [0.0, 100.0]");
	l4d_witch_range_vision = CreateConVar("l4d_witch_range_vision", "1000.0", " witch's vision range , witch will fellow you if in range [100.0, 5000.0] " );
 
	AutoExecConfig(true, "l4d_evil_witch");
	HookEvent("witch_spawn", witch_spawn); 
	HookEvent("witch_killed", witch_killed); 
	HookEvent("player_death", player_death);
	HookEvent("player_incapacitated", player_incapacitated ); 
	
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition",  round_end);	
	RegConsoleCmd("sm_walkwitch", sm_walkwitch); 
	ReplaceWitchId=0;
	HookWitchCount=0;
	Init();
}
public Action:round_start(Handle:event, const String:name[], bool:dontBroadcast)
{ 
	ReplaceWitchId=0;
	HookWitchCount=0;
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	ReplaceWitchId=0;
	HookWitchCount=0;
}
public OnMapStart()
{
    if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");		
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");		 
	}
	HookWitchCount=0;
}
 
public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
 	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	new witch =  GetEventInt(hEvent, "attackerentid") ;  
	if(victim>0 && witch>0)
	{		
		if(IsClientInGame(victim) && GetClientTeam(victim)==2)
		{
			StartSaveWitch(witch, victim);
		}
	}		
	return Plugin_Continue;	 
}
public Action:player_incapacitated(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
 	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	new witch =  GetEventInt(hEvent, "attackerentid") ;  
	if(victim>0 && witch>0)
	{		
		if(IsClientInGame(victim) && GetClientTeam(victim)==2)
		{
			StartSaveWitch(witch, victim);
		}
	}		
	return Plugin_Continue;	 
}
StartSaveWitch(witch, victim)
{ 
	if(IsWitch(witch)  && GetRandomFloat(0.0, 100.0)< GetConVarFloat(l4d_witch_chance_attacknext))
	{ 
		/*
		new Handle:h=CreateDataPack();
		WritePackCell(h, witch);
		WritePackCell(h, victim);
		CreateTimer(0.01, DelaySave, h, TIMER_FLAG_NO_MAPCHANGE );	
		*/
		SaveWitch(witch, victim);
	}	 
}
public Action:witch_killed(Handle:h_Event, const String:s_Name[], bool:b_DontBroadcast)
{
	
	new witchid = GetEventInt(h_Event, "witchid");
	if(witchid>0)
	{
		if(ReplaceWitchId==witchid)ReplaceWitchId=0;
		StopHookWitch(witchid);
	}
	return Plugin_Handled;
}
public Action:witch_spawn(Handle:h_Event, const String:s_Name[], bool:b_DontBroadcast)
{
	//PrintToChatAll("witch spawn");
	new witchid = GetEventInt(h_Event, "witchid");
	CreateTimer(0.1, DelayHookWitch, witchid, TIMER_FLAG_NO_MAPCHANGE );	
	//StartHookWitch(witchid);
	if(witchid>0 )
	{
		LoadWitch(witchid); 		
	}

}
public Action:sm_walkwitch(client,args)
{
	new witch=GetClientAimTarget(client, false);
	StartHookWitch(witch);
}
public Action:DelayHookWitch(Handle:timer, any:witch)
{
	StartHookWitch(witch);
}
new HookWitchs[100]; 
new bool:OnTrace[100];
new Float:ActionTime[100];
new Float:EnemyTime[100];
new Float:StuckTime[100];
new Float:PauseTime[100];
new Float:LastTime[100];
new Float:TargetDir[100][3];
new Float:LastPos[100][3];
new Float:LastSetPos[100][3];
 
new Enemy[100]; 

new anim_crawl; 
new anim_run; 
new anim_walk;  
new anim_run_crazy;
new anim_ducking;
new anim_threaten;

StartHookWitch(witch)
{
	StopHookWitch(witch);
	if(IsWitch(witch))
	{ 
		new index=AddWitch(witch);
		  
		EnemyTime[index]=GetEngineTime(); 
		Enemy[index]=0; 
		LastTime[index]=GetEngineTime()-0.01;
		StuckTime[index]=0.0;
		PauseTime[index]=0.0; 
		ActionTime[index]=0.0;
		OnTrace[index]=false;
	 
		GetEntPropVector(witch, Prop_Send, "m_vecOrigin", LastPos[index]);
		SetVector(TargetDir[index], GetRandomFloat(-1.0, 1.0), GetRandomFloat(-1.0, 1.0), 0.0);
		SetVector(LastSetPos[index], 0.0, 0.0, 0.0);
		NormalizeVector(TargetDir[index], TargetDir[index]); 
		SDKHook(witch, SDKHook_ThinkPost, ThinkWitch);
	}
}
StopHookWitch(witch)
{
	if(witch>0)
	{	
		SDKUnhook(witch, SDKHook_ThinkPost, ThinkWitch);		
		DeleteWitch(witch);
	}
}
DeleteWitch(witch)
{
	new find=-1;
	for(new i=0; i<HookWitchCount; i++)
	{
		if(witch==HookWitchs[i]) 
		{
			find=i; break;
		}
	}
	if(find>=0)
	{
		HookWitchs[find]=HookWitchs[HookWitchCount-1]; 
		EnemyTime[find]=EnemyTime[HookWitchCount-1];
		LastTime[find]=LastTime[HookWitchCount-1];
		Enemy[find]=Enemy[HookWitchCount-1];
		StuckTime[find]=StuckTime[HookWitchCount-1];
		PauseTime[find]=PauseTime[HookWitchCount-1];
		
		ActionTime[find]=StuckTime[HookWitchCount-1];
		OnTrace[find]=PauseTime[HookWitchCount-1];
		
		CopyVector(LastPos[HookWitchCount-1], LastPos[find]);
		CopyVector(TargetDir[HookWitchCount-1], TargetDir[find]);
		CopyVector(LastSetPos[HookWitchCount-1], LastSetPos[find]);
		HookWitchCount--;
	}
	
}
FindWitchIndex(witch)
{
	 
	for(new i=0; i<HookWitchCount; i++)
	{
		if(witch==HookWitchs[i])return i;
	}
	return -1;
}
AddWitch(witch)
{
	HookWitchs[HookWitchCount++]=witch;
	return HookWitchCount-1;
}
Float:GetRage(witch, &Float:rage, &wanderRage)
{
	rage=GetEntPropFloat(witch, Prop_Send, "m_rage");
	if(L4D2Version)wanderRage=GetEntPropFloat(witch, Prop_Send, "m_wanderrage");
	else wanderRage=0.0;
	if(rage>wanderRage)return rage;
	else return wanderRage;
}
SetRage(witch, rage, wanderRage)
{
	SetEntPropFloat(witch, Prop_Send, "m_rage", rage);
	if(L4D2Version)SetEntPropFloat(witch, Prop_Send, "m_wanderrage",wanderRage); 
	//PrintToChatAll("set m_rage %f   %f  ", rage, wanderRage );
}
public ThinkWitch(witch)
{
	if(!IsWitch(witch))
	{
		StopHookWitch(witch);
		return;
	}
	new index=FindWitchIndex(witch);
	if(index<0)
	{
		StopHookWitch(witch);
		return;
	}
	new Float:time=GetEngineTime();
	new Float:duration=time-LastTime[index];
	if(duration>0.1)duration=0.1;
	LastTime[index]=time;
	
	if(time-ActionTime[index]>5.0)
	{	
		if(GetRandomFloat(0.0, 100.0)<GetConVarFloat(l4d_witch_chance_followsurvivor))
		{
			OnTrace[index]=true;
		}
		else OnTrace[index]=false;
		ActionTime[index]=time;
	} 
	
	if(OnTrace[index]==false)return;
	
 
	new m_nSequence=GetEntProp(witch, Prop_Send, "m_nSequence");
	new m_mobRush=GetEntProp(witch, Prop_Send, "m_mobRush");
	new Float:m_rage;
	new Float:m_wanderrage;
	new Float:rage=GetRage(witch, m_rage, m_wanderrage);
	  
	//PrintToChatAll("rage %f m_rage %f m_wanderrage %f ", rage,m_rage,m_wanderrage );
	new flag=GetEntProp(witch, Prop_Send, "m_fFlags");
	new bool:onground=!(GetEntPropEnt(witch, Prop_Data, "m_hGroundEntity")==-1);
	
	decl Float:witchAngle[3]; 
	decl Float:witchPos[3];
	decl Float:lastPos[3]; 
	GetEntPropVector(witch, Prop_Send, "m_angRotation", witchAngle);
 	GetEntPropVector(witch, Prop_Send, "m_vecOrigin", witchPos);	
	CopyVector(LastPos[index], lastPos);
	CopyVector(witchPos, LastPos[index]);
	new m_hOwnerEntity=GetEntProp(witch, Prop_Send, "m_hOwnerEntity");   
	if( !onground || m_hOwnerEntity>0 || m_mobRush==1 || m_rage==1.0  )
	{		
		StuckTime[index]=0.0;
		return;
	}  
	if(rage>0.5)
	{
		StuckTime[index]=0.0;
		return; 
	} 	
	decl Float:up[3];  
 
	decl Float:newWitchPos[3];
	decl Float:newWitchAngle[3]; 
	 
	decl Float:moveDir[3]; 
	
	decl Float:temp[3]; 
	decl Float:temp2[3]; 
	new Float:moveSpeed=100.0;  
	
	SetVector(up, 0.0, 0.0, 1.0); 
 
	decl Float:targetPos[3];   
	
	if(time-EnemyTime[index]>1.0)
	{	
		Enemy[index]=FindNextEnemy(witch,witchPos );	 		
		EnemyTime[index]=time;  
	
	} 
	PauseTime[index]-=duration; 
	Enemy[index]=FreshEnemy(Enemy[index], witchPos, targetPos  );
	if(Enemy[index])
	{ 
		if(PauseTime[index]<=0.0)
		{
			SubtractVectors(targetPos, witchPos, TargetDir[index]);
			TargetDir[index][2]=0.0;
			NormalizeVector(TargetDir[index], TargetDir[index]);	 
			//PrintToChatAll("eneym %d", Enemy[index]);
		}
		
	}
	else
	{
		if(L4D2Version)return;
		new newSequence;
		new newFlag;
		 
		newSequence=anim_ducking;
		newFlag=flag | FL_DUCKING; 
		 
		SetEntProp(witch, Prop_Send, "m_fFlags",newFlag);
		if(m_nSequence!=newSequence)
		{
			SetEntProp(witch, Prop_Send, "m_nSequence" ,newSequence); 
			SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate" ,1.0); 
		}
		return;
	}
   
	new bool:stuck=false;
	StuckTime[index]+=duration; 
	if(StuckTime[index]>0.5)
	{  
		StuckTime[index]=0.0;
		CopyVector(witchPos, temp);
		CopyVector(LastSetPos[index], temp2);
		CopyVector(witchPos, LastSetPos[index] );
		temp2[2]=temp[2]=0.0;  
		new Float:a=GetVectorDistance(temp2, temp); 
		if(a<10.0)
		{ 
			RotateVector(up, TargetDir[index], GetRandomFloat(50.0, 310.0)*Pai/180.0, TargetDir[index]);
			
			TargetDir[index][2]=0.0;
			NormalizeVector(TargetDir[index],TargetDir[index]); 
			PauseTime[index]=2.0;
		}
	} 

	new newSequence=anim_walk;
	moveSpeed=70.0;
	new newFlag=flag & ~FL_DUCKING; 

	CopyVector(TargetDir[index],moveDir);	 	
	
	GetVectorAngles(moveDir,newWitchAngle);
	newWitchAngle[0]=0.0;
	
	CopyVector(moveDir,temp);
	ScaleVector(temp, moveSpeed*duration);
	AddVectors(witchPos,temp,newWitchPos);
	TeleportEntity(witch, newWitchPos, newWitchAngle,  NULL_VECTOR);
	//ShowDir(0, witchPos, TargetDir[index], 0.06);
	CopyVector(witchPos, lastPos);	
	SetEntProp(witch, Prop_Send, "m_fFlags",newFlag);
	 
	if(m_nSequence!=newSequence)
	{
		SetEntProp(witch, Prop_Send, "m_nSequence" ,newSequence); 
		SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate" ,1.0); 
	}
	
}

FreshEnemy(enemy,  Float:witchPos[3], Float:enemyPos[3] )
{
 
	new Float:visionRange=GetConVarFloat(l4d_witch_range_vision);
	if(visionRange==0.0)return 0; 	
	if(enemy>0 && IsClientInGame(enemy) && IsPlayerAlive(enemy) && GetClientTeam(enemy)==2)
	{ 
		GetClientAbsOrigin(enemy, enemyPos);  
	}
	else enemy=0;
	return enemy;
}
FindNextEnemy(witch,Float:witchPos[3] )
{ 
	witch+=0; 
	new Float:visionRange=GetConVarFloat(l4d_witch_range_vision);
	if(visionRange==0.0)return 0;	 
 		 
	new Float:minDis=9999.0;
	new selectedPlayer=0;
	decl Float:playerPos[3];
	new Float:distance=0.0;
	for(new i=1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i)==2 && IsPlayerAlive(i) )
		{
		 
			GetClientAbsOrigin(i, playerPos);
			new Float:dis=GetVectorDistance(playerPos, witchPos);  
			if(dis<=visionRange && dis<=minDis)
			{
				selectedPlayer=i ;
				minDis=dis;
				distance=dis;
				
			}
		}
	} 
 
	return selectedPlayer;	 
}
LoadWitch(witchid)
{
	new Float:time=GetEngineTime();
	new oldwitch=ReplaceWitchId;
	ReplaceWitchId=0;	
	if(IsWitch(oldwitch ) && time-ReplaceWitchTime<0.2)
	{	
		StopHookWitch(oldwitch);
		AcceptEntityInput(oldwitch, "kill");	 	 
		SetEntProp(witchid, Prop_Send, "m_nSequence",ReplaceWitchSequence);		
		//SetEntProp(witchid, Prop_Send, "m_mobRush",ReplaceWitchRush );
		if(L4D2Version)SetEntPropFloat(witchid , Prop_Send,"m_flModelScale", ReplaceWitchScale); 
		SetEntProp(witchid, Prop_Send, "m_fFlags", ReplaceWitchFlag);
		TeleportEntity(witchid, ReplaceWitchPos, ReplaceWitchAngle, NULL_VECTOR);		
		if(IsSurvivor(ReplaceWitchVictim))
		{
			SetRage(witchid, ReplaceWitchRage ,ReplaceWitchWanderRage);
			new Handle:h=CreateDataPack();
			WritePackCell(h, witchid);
			WritePackCell(h, ReplaceWitchVictim);			 
			CreateTimer(0.1, DelayShot, h, TIMER_FLAG_NO_MAPCHANGE );	
			
		}
		else 
		{
			SetRage(witchid, 0.9 ,0.9);  
			SetEntProp(witchid, Prop_Send, "m_mobRush",0 );
		} 
	}		
}
SaveWitch(ent, victim)
{
	if(IsWitch(ent,true ))
	{
		new Float:m_rage;
		new Float:m_wanderRage;
		GetRage(ent, m_rage ,m_wanderRage);
		new flag=GetEntProp(ent, Prop_Send, "m_fFlags");
		 
		new m_nSequence = GetEntProp(ent, Prop_Data, "m_nSequence");
		new Float:scale=0.0;
		if(L4D2Version)scale=GetEntPropFloat(ent , Prop_Send,"m_flModelScale");  
		 
		{		
			ReplaceWitchId=ent;
			ReplaceWitchTime=GetEngineTime();
			GetEntPropVector(ent, Prop_Send, "m_vecOrigin", ReplaceWitchPos); 
			GetEntPropVector(ent, Prop_Send, "m_angRotation", ReplaceWitchAngle);
			ReplaceWitchSequence=m_nSequence;
			ReplaceWitchRage=m_rage;
			ReplaceWitchWanderRage=m_wanderRage;
			ReplaceWitchScale=scale;
			ReplaceWitchFlag=flag;
			if(GetConVarInt(l4d_witch_changetarget)==1)ReplaceWitchVictim=GetVictim(victim,ReplaceWitchPos );	
			else if(IsPlayerIncapped(victim))
			{
				ReplaceWitchVictim=victim;
			}
			ReplaceWitchRush=1;
			if(ReplaceWitchVictim>0)
			{
				ReplaceWitchRush=1;
				//PrintToChatAll("next target is %N", ReplaceWitchVictim);
			}
			ReplaceWitchRush=ReplaceWitchRush+1-1;
			SpawnCommand("z_spawn", "witch"); 
		}
	}
}
 
public Action:DelayShot(Handle:timer, Handle:h)
{
	ResetPack(h);
 	new witchid=ReadPackCell(h);
	new attacker=ReadPackCell(h);
	CloseHandle(h);
	if(!IsWitch(witchid))return;
	if(IsSurvivor(attacker))
	{
		DoPointHurtForInfected(witchid, attacker, 1.0);
		SetEntProp(witchid, Prop_Send, "m_mobRush",1 );
	}
}
public Action:DelaySave(Handle:timer, Handle:h)
{
	ResetPack(h);
 	new witch=ReadPackCell(h);
	new victim=ReadPackCell(h);
	CloseHandle(h);
	if(IsWitch(witch))
	{
		SaveWitch(witch, victim);
	}
	 
}

GetVictim(except, Float:witchPos[3])
{
	new Float:range=GetConVarFloat(l4d_witch_attack_range);
	decl victim[MAXPLAYERS+1];
	decl Float:rage[MAXPLAYERS+1];
	new count=0;
	new Float:minDis=range;
	new Float:ePos[3];
	new selected=0;
	for(new i=1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i)==2 && IsPlayerAlive(i) && i!=except && !IsPlayerIncapped(i))
		{
			
			GetClientAbsOrigin(i, ePos);
			new Float:dis=GetVectorDistance(ePos, witchPos);
			if(dis<=minDis )
			{
				selected=i;
				minDis=dis;
			}
		}
	} 
	return selected;
}
bool:IsPlayerIncapped(client)
{
	if(client>0 && IsClientInGame(client) && GetClientTeam(client)==2 && IsPlayerAlive(client))
	{
		if (GetEntProp(client, Prop_Send, "m_isIncapacitated", 1)) return true;
		
	}
	return false;
}
SpawnCommand(String:command[], String:arguments[] = "")
{
	new client=0;
	for(new i=1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i))
		{
			client=i;
			break;
		}
	}
	if (client>0)
	{ 
		new flags = GetCommandFlags(command);
		SetCommandFlags(command, flags & ~FCVAR_CHEAT);
		FakeClientCommand(client, "%s %s", command, arguments);
		SetCommandFlags(command, flags);
	}
}


IsWitch(witch, bool:alive=false)
{
	if(witch>0 && IsValidEdict(witch) && IsValidEntity(witch))
	{
		decl String:classname[32];
		GetEdictClassname(witch, classname, sizeof(classname));
		if(StrEqual(classname, "witch"))
		{
			if(alive)
			{
			}
			return true;
		}
	}
	return false;
}
IsSurvivor(client)
{
	if(client>0 && IsClientInGame(client) && GetClientTeam(client)==2 && IsPlayerAlive(client))
	{
		return true;	 
	}
	return false;
}
CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{		
		DispatchKeyValue(pointHurt,"Damage","10");
		if(L4D2Version)	DispatchKeyValue(pointHurt,"DamageType","2"); 
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
 new String:N[10];
DoPointHurtForInfected(victim, attacker=0, Float:FireDamage)
{
	new g_PointHurt=CreatePointHurt();	 			
	Format(N, 20, "target%d", victim);
	DispatchKeyValue(victim,"targetname", N);
	DispatchKeyValue(g_PointHurt,"DamageTarget", N); 
 	DispatchKeyValueFloat(g_PointHurt,"Damage", FireDamage);
	AcceptEntityInput(g_PointHurt,"Hurt",(attacker>0)?attacker:-1);
	AcceptEntityInput(g_PointHurt,"kill" ); 
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GameMode+=0;
 
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		 
		L4D2Version=true;
	}	
	else
	{
		 
		L4D2Version=false;
	}
 
}
PrintVector(String:s[], Float:target[3])
{
	PrintToChatAll("%s - %f %f %f", s, target[0], target[1], target[2]); 
}
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
	target[1]=source[1];
	target[2]=source[2];
}
SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}
 
//draw line between pos1 and pos2
ShowLaser(colortype,Float:pos1[3], Float:pos2[3], Float:life=10.0,  Float:width1=1.0, Float:width2=11.0)
{
	decl color[4];
	if(colortype==1)
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==2)
	{
		color[0] = 0; 
		color[1] = 200;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==3)
	{
		color[0] = 0; 
		color[1] = 0;
		color[2] = 200;
		color[3] = 230; 
	}
	else 
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230; 		
	}

	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
//draw line between pos1 and pos2
ShowPos(color, Float:pos1[3], Float:pos2[3],Float:life=10.0, Float:length=0.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:t[3];
	if(length!=0.0)
	{
		SubtractVectors(pos2, pos1, t);	 
		NormalizeVector(t,t);
		ScaleVector(t, length);
		AddVectors(pos1, t,t);
	}
	else 
	{
		CopyVector(pos2,t);
	}
	ShowLaser(color,pos1, t, life,   width1, width2);
}
//draw line start from pos, the line's drection is dir.
ShowDir(color,Float:pos[3], Float:dir[3],Float:life=10.0, Float:length=200.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:pos2[3];
	CopyVector(dir, pos2);
	NormalizeVector(pos2,pos2);
	ScaleVector(pos2, length);
	AddVectors(pos, pos2,pos2);
	ShowLaser(color,pos, pos2, life,   width1, width2);
}
//draw line start from pos, the line's angle is angle.
ShowAngle(color,Float:pos[3], Float:angle[3],Float:life=10.0, Float:length=200.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:pos2[3];
	GetAngleVectors(angle, pos2, NULL_VECTOR, NULL_VECTOR);
 
	NormalizeVector(pos2,pos2);
	ScaleVector(pos2, length);
	AddVectors(pos, pos2,pos2);
	ShowLaser(color,pos, pos2, life, width1, width2);
}
Init()
{
	if(L4D2Version)
	{
		anim_ducking=4;
		anim_crawl=38; 
		anim_run=8; //8 
		anim_walk=10;  
		anim_run_crazy=6;//7
		anim_threaten=31; 
	}
	else
	{
		anim_ducking=2;  
		anim_crawl=30;		 
		anim_run=6;  
		anim_walk=6; //10 ,11
		anim_run_crazy=4; 
		anim_threaten=22;  //23
	}
}
RotateVector(Float:direction[3], Float:vec[3], Float:alfa, Float:result[3])
{
  /*
   on rotateVector (v, u, alfa)
  -- rotates vector v around u alfa degrees
  -- returns rotated vector 
  -----------------------------------------
  u.normalize()
  alfa = alfa*pi()/180 -- alfa in rads
  uv = u.cross(v)
  vect = v + sin (alfa) * uv + 2*power(sin(alfa/2), 2) * (u.cross(uv))
  return vect
	end
   */
   	decl Float:v[3];
	CopyVector(vec,v);
	
	decl Float:u[3];
	CopyVector(direction,u);
	NormalizeVector(u,u);
	
	decl Float:uv[3];
	GetVectorCrossProduct(u,v,uv);
	
	decl Float:sinuv[3];
	CopyVector(uv, sinuv);
	ScaleVector(sinuv, Sine(alfa));
	
	decl Float:uuv[3];
	GetVectorCrossProduct(u,uv,uuv);
	ScaleVector(uuv, 2.0*Pow(Sine(alfa*0.5), 2.0));	
	
	AddVectors(v, sinuv, result);
	AddVectors(result, uuv, result);
	
 
} 
Float:GetAngle(Float:x1[3], Float:x2[3])
{
	return ArcCosine(GetVectorDotProduct(x1, x2)/(GetVectorLength(x1)*GetVectorLength(x2)));
}